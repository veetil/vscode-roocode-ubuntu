# Step 3: Docker Implementation - Entrypoint Script and Input Handling

## Objective

Implement a comprehensive entrypoint script and input handling system for the RooCode Docker container. This includes:
- Processing environment variables
- Handling file inputs
- Validating inputs
- Setting up the container environment for RooCode

## Input Handling Design

### Environment Variables

The container will accept the following environment variables:
- `QUESTION`: The user question to save to question.md (required)
- `EXPT`: The experiment folder name (required)
- `FILES`: A comma-separated list of source:destination file pairs (optional)
- `PROMPT`: The prompt text to save to outline.md (optional)
- `DEBUG`: Enable debug mode if set to "true" (optional)

### File Inputs

The container will accept file inputs through a mounted volume at `/data/input`. The `FILES` environment variable will reference files in this directory.

### Input Validation

The entrypoint script will validate:
- Required environment variables are set
- Referenced input files exist
- The experiment folder name is valid

## Entrypoint Script Implementation

```bash
#!/bin/bash
# entrypoint.sh - Docker container entrypoint script

# Enable debug mode if requested
if [ "${DEBUG}" = "true" ]; then
  set -x
fi

# Set error handling
set -e

# Constants
LAUNCH_ROO_DIR="/home/ubuntu/LaunchRoo"
EVALS_DIR="${LAUNCH_ROO_DIR}/evals"
PYTHON_DIR="${EVALS_DIR}/python"
INPUT_DIR="/data/input"
OUTPUT_DIR="/data/output"

# Function to log messages
function log {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Function to log errors
function error {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >&2
}

# Function to start Xvfb
function start_xvfb {
  log "Starting Xvfb..."
  
  # Start Xvfb
  Xvfb :99 -screen 0 1024x768x24 &
  export DISPLAY=:99
  
  # Wait for Xvfb to start
  sleep 2
  
  # Check if Xvfb is running
  if ! xdpyinfo -display :99 >/dev/null 2>&1; then
    error "Xvfb failed to start"
    exit 1
  fi
  
  log "Xvfb started successfully"
}

# Function to validate inputs
function validate_inputs {
  log "Validating inputs..."
  
  # Check required environment variables
  if [ -z "${QUESTION}" ]; then
    error "QUESTION environment variable is required"
    exit 1
  fi
  
  if [ -z "${EXPT}" ]; then
    error "EXPT environment variable is required"
    exit 1
  fi
  
  # Validate experiment folder name
  if [[ ! "${EXPT}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    error "Invalid experiment folder name: ${EXPT}"
    error "Experiment folder name must contain only letters, numbers, underscores, and hyphens"
    exit 1
  fi
  
  # Validate FILES format if provided
  if [ -n "${FILES}" ]; then
    IFS=',' read -ra FILE_PAIRS <<< "${FILES}"
    
    for pair in "${FILE_PAIRS[@]}"; do
      IFS=':' read -ra PARTS <<< "${pair}"
      
      if [ ${#PARTS[@]} -ne 2 ]; then
        error "Invalid file pair format: ${pair}"
        error "Expected format: source:destination"
        exit 1
      fi
      
      local source="${INPUT_DIR}/${PARTS[0]}"
      
      # Verify the source file exists
      if [ ! -f "${source}" ]; then
        error "Source file does not exist: ${source}"
        exit 1
      fi
    done
  fi
  
  log "Inputs validated successfully"
}

# Function to prepare the environment
function prepare_environment {
  log "Preparing environment..."
  
  # Create output directory if it doesn't exist
  mkdir -p "${OUTPUT_DIR}"
  
  # Create experiment directory if it doesn't exist
  mkdir -p "${PYTHON_DIR}/${EXPT}"
  mkdir -p "${PYTHON_DIR}/${EXPT}/docs"
  
  log "Environment prepared successfully"
}

# Function to process question
function process_question {
  log "Processing question..."
  
  local question_file="${PYTHON_DIR}/${EXPT}/question.md"
  
  # Create the file and write the question
  echo "${QUESTION}" > "${question_file}"
  
  # Copy to output directory for reference
  cp "${question_file}" "${OUTPUT_DIR}/question.md"
  
  log "Question processed successfully"
}

# Function to process prompt
function process_prompt {
  # Skip if no prompt was provided
  if [ -z "${PROMPT}" ]; then
    log "No prompt provided, skipping outline.md creation"
    return 0
  fi
  
  log "Processing prompt..."
  
  local outline_file="${PYTHON_DIR}/${EXPT}/outline.md"
  
  # Create the file and write the prompt
  echo "${PROMPT}" > "${outline_file}"
  
  # Copy to output directory for reference
  cp "${outline_file}" "${OUTPUT_DIR}/outline.md"
  
  log "Prompt processed successfully"
}

# Function to process files
function process_files {
  # Skip if no files were specified
  if [ -z "${FILES}" ]; then
    log "No files specified, skipping file copying"
    return 0
  fi
  
  log "Processing files..."
  
  # Split the comma-separated list of file pairs
  IFS=',' read -ra FILE_PAIRS <<< "${FILES}"
  
  for pair in "${FILE_PAIRS[@]}"; do
    # Split the source:destination pair
    IFS=':' read -ra PARTS <<< "${pair}"
    
    local source="${INPUT_DIR}/${PARTS[0]}"
    local destination="${PARTS[1]}"
    
    # Create the destination directory if it doesn't exist
    local dest_dir="${PYTHON_DIR}/${EXPT}"
    if [ -n "${destination}" ]; then
      dest_dir="${PYTHON_DIR}/${EXPT}/${destination}"
      mkdir -p "${dest_dir}"
    fi
    
    # Copy the file
    cp "${source}" "${dest_dir}/"
    
    log "Copied ${source} to ${dest_dir}/"
  done
  
  log "Files processed successfully"
}

# Main function
function main {
  log "Starting RooCode Docker container..."
  
  # Start Xvfb
  start_xvfb
  
  # Validate inputs
  validate_inputs
  
  # Prepare environment
  prepare_environment
  
  # Process inputs
  process_question
  process_prompt
  process_files
  
  # Print summary
  log "Input processing completed successfully"
  log "Question: ${QUESTION}"
  log "Experiment: ${EXPT}"
  log "Files: ${FILES}"
  log "Prompt: ${PROMPT}"
  
  # Placeholder for RooCode execution
  log "RooCode execution would happen here"
  
  log "RooCode Docker container completed successfully"
}

# Execute main function
main
```

## Testing

We'll create a test script called `test-entrypoint.sh` that:
1. Creates test input files
2. Sets test environment variables
3. Runs the entrypoint script in a test environment
4. Verifies that inputs are processed correctly
5. Tests various error conditions

```bash
#!/bin/bash
# test-entrypoint.sh - Test the entrypoint script

# Create test directories
mkdir -p test/input test/output test/python/test-expt/docs

# Create test input files
echo "Test file 1" > test/input/file1.txt
echo "Test file 2" > test/input/file2.txt

# Set test environment variables
export QUESTION="Test question"
export EXPT="test-expt"
export FILES="file1.txt:,file2.txt:docs"
export PROMPT="Test prompt"
export DEBUG="true"

# Override constants for testing
export INPUT_DIR="$(pwd)/test/input"
export OUTPUT_DIR="$(pwd)/test/output"
export PYTHON_DIR="$(pwd)/test/python"

# Run the entrypoint script
./entrypoint.sh

# Check if the script ran successfully
if [ $? -ne 0 ]; then
  echo "Error: Entrypoint script failed"
  exit 1
fi

# Verify that files were created correctly
if [ ! -f "test/python/test-expt/question.md" ]; then
  echo "Error: question.md was not created"
  exit 1
fi

if [ ! -f "test/python/test-expt/outline.md" ]; then
  echo "Error: outline.md was not created"
  exit 1
fi

if [ ! -f "test/python/test-expt/file1.txt" ]; then
  echo "Error: file1.txt was not copied"
  exit 1
fi

if [ ! -f "test/python/test-expt/docs/file2.txt" ]; then
  echo "Error: file2.txt was not copied to docs"
  exit 1
fi

echo "All tests passed!"
```

## Next Steps

In the next step, we'll implement the RooCode installation and configuration within the Docker container. This will include:
- Cloning the RooCode repository
- Installing dependencies
- Configuring RooCode for use within the container
- Setting up the virtual display for RooCode

We'll build on the entrypoint script and input handling implemented in this step.