# Step 5: Docker Implementation - Modular System Integration

## Objective

Implement the modular system within the Docker container. This includes:
- Integrating the modular system from the previous plan
- Adapting it for use within the Docker container
- Handling git operations within the container
- Running the RooCode workflow

## Modular System Integration Design

### Git Operations

We'll implement functions to:
1. Initialize git repository if needed
2. Remove remote if it exists
3. Create a new branch
4. Add and commit changes
5. Handle potential errors

### Workflow Execution

We'll implement functions to:
1. Run the RooCode CLI with the experiment folder
2. Capture the output
3. Extract test results and branch name
4. Handle potential errors

## Implementation

We'll extend the entrypoint script with modular system functions:

```bash
# Function to handle git operations
function handle_git_operations {
  log "Handling git operations..."
  
  # Change to the evals directory
  cd "${EVALS_DIR}"
  
  # Check if git is initialized
  if [ ! -d ".git" ]; then
    log "Initializing git repository..."
    git init
    git config --local user.name "RooCode Docker"
    git config --local user.email "roocode-docker@example.com"
  fi
  
  # Check for remote and remove if it exists
  if git remote | grep -q "origin"; then
    log "Removing origin remote..."
    git remote remove origin
  fi
  
  # Checkout main branch
  log "Checking out main branch..."
  if git branch | grep -q "main"; then
    git checkout main
  else
    git checkout -b main
  fi
  
  # Add and commit changes
  log "Adding and committing changes..."
  git add -A
  git commit -m "Add experiment files for ${EXPT}" || true
  
  log "Git operations handled successfully"
}

# Function to run RooCode workflow
function run_roocode_workflow {
  log "Running RooCode workflow..."
  
  # Change to the LaunchRoo directory
  cd "${LAUNCH_ROO_DIR}"
  
  # Create a unique branch name
  local branch_name="roocode-${EXPT}-$(date +%Y%m%d%H%M%S)"
  
  # Run the RooCode CLI
  log "Executing RooCode CLI..."
  ./run-cli-with-xvfb.sh python "${EXPT}" > "${OUTPUT_DIR}/roocode-output.log" 2>&1
  
  # Check if the command was successful
  if [ $? -ne 0 ]; then
    error "RooCode CLI execution failed"
    cat "${OUTPUT_DIR}/roocode-output.log" >&2
    exit 1
  fi
  
  # Extract test results and branch name from the output
  local tests_passed=false
  local actual_branch_name=""
  
  if grep -q "All tests passed" "${OUTPUT_DIR}/roocode-output.log"; then
    tests_passed=true
  fi
  
  # Extract the branch name from the output
  actual_branch_name=$(grep -o "Branch: [a-zA-Z0-9_-]*" "${OUTPUT_DIR}/roocode-output.log" | cut -d' ' -f2)
  
  # If branch name wasn't found, use the generated one
  if [ -z "${actual_branch_name}" ]; then
    actual_branch_name="${branch_name}"
  fi
  
  # Write results to output files
  echo "Tests passed: ${tests_passed}" > "${OUTPUT_DIR}/test-results.txt"
  echo "Branch name: ${actual_branch_name}" >> "${OUTPUT_DIR}/test-results.txt"
  
  # Print results
  log "Tests passed: ${tests_passed}"
  log "Branch name: ${actual_branch_name}"
  
  log "RooCode workflow completed"
}
```

We'll update the `main` function to call these new functions:

```bash
# Main function
function main {
  log "Starting RooCode Docker container..."
  
  # Start Xvfb
  start_xvfb
  
  # Configure git
  configure_git
  
  # Install RooCode (if not already installed)
  install_roocode
  
  # Configure RooCode
  configure_roocode
  
  # Validate inputs
  validate_inputs
  
  # Prepare environment
  prepare_environment
  
  # Process inputs
  process_question
  process_prompt
  process_files
  
  # Handle git operations
  handle_git_operations
  
  # Run RooCode workflow
  run_roocode_workflow
  
  # Print summary
  log "RooCode Docker container completed successfully"
}
```

## Complete Entrypoint Script

Here's the complete entrypoint script with all functions:

```bash
#!/bin/bash
# entrypoint.sh - Docker container entrypoint script

# Enable debug mode if requested
if [ "${DEBUG}" = "true" ]; then
  set -x
fi

# Set error handling
set -e

# Constants
LAUNCH_ROO_DIR="/home/ubuntu/LaunchRoo"
EVALS_DIR="${LAUNCH_ROO_DIR}/evals"
PYTHON_DIR="${EVALS_DIR}/python"
INPUT_DIR="/data/input"
OUTPUT_DIR="/data/output"

# Function to log messages
function log {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] $1"
}

# Function to log errors
function error {
  echo "[$(date '+%Y-%m-%d %H:%M:%S')] ERROR: $1" >&2
}

# Function to start Xvfb
function start_xvfb {
  log "Starting Xvfb..."
  
  # Start Xvfb
  Xvfb :99 -screen 0 1024x768x24 &
  export DISPLAY=:99
  
  # Wait for Xvfb to start
  sleep 2
  
  # Check if Xvfb is running
  if ! xdpyinfo -display :99 >/dev/null 2>&1; then
    error "Xvfb failed to start"
    exit 1
  fi
  
  log "Xvfb started successfully"
}

# Function to configure git
function configure_git {
  log "Configuring git..."
  
  # Set git configuration
  git config --global user.name "RooCode Docker"
  git config --global user.email "roocode-docker@example.com"
  
  log "Git configured successfully"
}

# Function to install RooCode
function install_roocode {
  log "Installing RooCode..."
  
  # Check if RooCode is already installed
  if [ -d "${LAUNCH_ROO_DIR}" ]; then
    log "RooCode is already installed"
    return 0
  fi
  
  # Clone RooCode repository
  git clone https://github.com/example/LaunchRoo.git "${LAUNCH_ROO_DIR}"
  
  # Check if the clone was successful
  if [ $? -ne 0 ]; then
    error "Failed to clone RooCode repository"
    exit 1
  fi
  
  # Install dependencies
  cd "${LAUNCH_ROO_DIR}"
  npm install
  
  # Check if the installation was successful
  if [ $? -ne 0 ]; then
    error "Failed to install RooCode dependencies"
    exit 1
  fi
  
  log "RooCode installed successfully"
}

# Function to configure RooCode
function configure_roocode {
  log "Configuring RooCode..."
  
  # Create run-cli-with-xvfb.sh script
  cat > "${LAUNCH_ROO_DIR}/run-cli-with-xvfb.sh" << 'EOF'
#!/bin/bash
# run-cli-with-xvfb.sh - Run RooCode CLI with virtual display

# Check if Xvfb is already running
if ! xdpyinfo -display :99 >/dev/null 2>&1; then
  echo "Starting Xvfb..."
  Xvfb :99 -screen 0 1024x768x24 &
  export DISPLAY=:99
  sleep 2
fi

# Run RooCode CLI
cd "$(dirname "$0")"
node ./cli.js "$@"
EOF
  
  # Make the script executable
  chmod +x "${LAUNCH_ROO_DIR}/run-cli-with-xvfb.sh"
  
  log "RooCode configured successfully"
}

# Function to validate inputs
function validate_inputs {
  log "Validating inputs..."
  
  # Check required environment variables
  if [ -z "${QUESTION}" ]; then
    error "QUESTION environment variable is required"
    exit 1
  fi
  
  if [ -z "${EXPT}" ]; then
    error "EXPT environment variable is required"
    exit 1
  fi
  
  # Validate experiment folder name
  if [[ ! "${EXPT}" =~ ^[a-zA-Z0-9_-]+$ ]]; then
    error "Invalid experiment folder name: ${EXPT}"
    error "Experiment folder name must contain only letters, numbers, underscores, and hyphens"
    exit 1
  fi
  
  # Validate FILES format if provided
  if [ -n "${FILES}" ]; then
    IFS=',' read -ra FILE_PAIRS <<< "${FILES}"
    
    for pair in "${FILE_PAIRS[@]}"; do
      IFS=':' read -ra PARTS <<< "${pair}"
      
      if [ ${#PARTS[@]} -ne 2 ]; then
        error "Invalid file pair format: ${pair}"
        error "Expected format: source:destination"
        exit 1
      fi
      
      local source="${INPUT_DIR}/${PARTS[0]}"
      
      # Verify the source file exists
      if [ ! -f "${source}" ]; then
        error "Source file does not exist: ${source}"
        exit 1
      fi
    done
  fi
  
  log "Inputs validated successfully"
}

# Function to prepare the environment
function prepare_environment {
  log "Preparing environment..."
  
  # Create output directory if it doesn't exist
  mkdir -p "${OUTPUT_DIR}"
  
  # Create experiment directory if it doesn't exist
  mkdir -p "${PYTHON_DIR}/${EXPT}"
  mkdir -p "${PYTHON_DIR}/${EXPT}/docs"
  
  log "Environment prepared successfully"
}

# Function to process question
function process_question {
  log "Processing question..."
  
  local question_file="${PYTHON_DIR}/${EXPT}/question.md"
  
  # Create the file and write the question
  echo "${QUESTION}" > "${question_file}"
  
  # Copy to output directory for reference
  cp "${question_file}" "${OUTPUT_DIR}/question.md"
  
  log "Question processed successfully"
}

# Function to process prompt
function process_prompt {
  # Skip if no prompt was provided
  if [ -z "${PROMPT}" ]; then
    log "No prompt provided, skipping outline.md creation"
    return 0
  fi
  
  log "Processing prompt..."
  
  local outline_file="${PYTHON_DIR}/${EXPT}/outline.md"
  
  # Create the file and write the prompt
  echo "${PROMPT}" > "${outline_file}"
  
  # Copy to output directory for reference
  cp "${outline_file}" "${OUTPUT_DIR}/outline.md"
  
  log "Prompt processed successfully"
}

# Function to process files
function process_files {
  # Skip if no files were specified
  if [ -z "${FILES}" ]; then
    log "No files specified, skipping file copying"
    return 0
  fi
  
  log "Processing files..."
  
  # Split the comma-separated list of file pairs
  IFS=',' read -ra FILE_PAIRS <<< "${FILES}"
  
  for pair in "${FILE_PAIRS[@]}"; do
    # Split the source:destination pair
    IFS=':' read -ra PARTS <<< "${pair}"
    
    local source="${INPUT_DIR}/${PARTS[0]}"
    local destination="${PARTS[1]}"
    
    # Create the destination directory if it doesn't exist
    local dest_dir="${PYTHON_DIR}/${EXPT}"
    if [ -n "${destination}" ]; then
      dest_dir="${PYTHON_DIR}/${EXPT}/${destination}"
      mkdir -p "${dest_dir}"
    fi
    
    # Copy the file
    cp "${source}" "${dest_dir}/"
    
    log "Copied ${source} to ${dest_dir}/"
  done
  
  log "Files processed successfully"
}

# Function to handle git operations
function handle_git_operations {
  log "Handling git operations..."
  
  # Change to the evals directory
  cd "${EVALS_DIR}"
  
  # Check if git is initialized
  if [ ! -d ".git" ]; then
    log "Initializing git repository..."
    git init
    git config --local user.name "RooCode Docker"
    git config --local user.email "roocode-docker@example.com"
  fi
  
  # Check for remote and remove if it exists
  if git remote | grep -q "origin"; then
    log "Removing origin remote..."
    git remote remove origin
  fi
  
  # Checkout main branch
  log "Checking out main branch..."
  if git branch | grep -q "main"; then
    git checkout main
  else
    git checkout -b main
  fi
  
  # Add and commit changes
  log "Adding and committing changes..."
  git add -A
  git commit -m "Add experiment files for ${EXPT}" || true
  
  log "Git operations handled successfully"
}

# Function to run RooCode workflow
function run_roocode_workflow {
  log "Running RooCode workflow..."
  
  # Change to the LaunchRoo directory
  cd "${LAUNCH_ROO_DIR}"
  
  # Create a unique branch name
  local branch_name="roocode-${EXPT}-$(date +%Y%m%d%H%M%S)"
  
  # Run the RooCode CLI
  log "Executing RooCode CLI..."
  ./run-cli-with-xvfb.sh python "${EXPT}" > "${OUTPUT_DIR}/roocode-output.log" 2>&1
  
  # Check if the command was successful
  if [ $? -ne 0 ]; then
    error "RooCode CLI execution failed"
    cat "${OUTPUT_DIR}/roocode-output.log" >&2
    exit 1
  fi
  
  # Extract test results and branch name from the output
  local tests_passed=false
  local actual_branch_name=""
  
  if grep -q "All tests passed" "${OUTPUT_DIR}/roocode-output.log"; then
    tests_passed=true
  fi
  
  # Extract the branch name from the output
  actual_branch_name=$(grep -o "Branch: [a-zA-Z0-9_-]*" "${OUTPUT_DIR}/roocode-output.log" | cut -d' ' -f2)
  
  # If branch name wasn't found, use the generated one
  if [ -z "${actual_branch_name}" ]; then
    actual_branch_name="${branch_name}"
  fi
  
  # Write results to output files
  echo "Tests passed: ${tests_passed}" > "${OUTPUT_DIR}/test-results.txt"
  echo "Branch name: ${actual_branch_name}" >> "${OUTPUT_DIR}/test-results.txt"
  
  # Print results
  log "Tests passed: ${tests_passed}"
  log "Branch name: ${actual_branch_name}"
  
  log "RooCode workflow completed"
}

# Main function
function main {
  log "Starting RooCode Docker container..."
  
  # Start Xvfb
  start_xvfb
  
  # Configure git
  configure_git
  
  # Install RooCode (if not already installed)
  install_roocode
  
  # Configure RooCode
  configure_roocode
  
  # Validate inputs
  validate_inputs
  
  # Prepare environment
  prepare_environment
  
  # Process inputs
  process_question
  process_prompt
  process_files
  
  # Handle git operations
  handle_git_operations
  
  # Run RooCode workflow
  run_roocode_workflow
  
  # Print summary
  log "RooCode Docker container completed successfully"
}

# Execute main function
main
```

## Testing

We'll create a test script called `test-modular-system.sh` that:
1. Builds the Docker image with the modular system
2. Runs the container with test inputs
3. Verifies that the modular system works correctly
4. Checks the output files for test results and branch name

```bash
#!/bin/bash
# test-modular-system.sh - Test the modular system

# Build the Docker image
docker build -t roocode-modular .

# Check if the build was successful
if [ $? -ne 0 ]; then
  echo "Error: Docker build failed"
  exit 1
fi

# Create test input files
mkdir -p test/input
echo "Test question" > test/input/question.txt

# Run the Docker container
docker run --rm \
  -e QUESTION="Test question" \
  -e EXPT="test-expt" \
  -v "$(pwd)/test/input:/data/input" \
  -v "$(pwd)/test/output:/data/output" \
  roocode-modular

# Check if the container ran successfully
if [ $? -ne 0 ]; then
  echo "Error: Docker container failed"
  exit 1
fi

# Check if the output files exist
if [ ! -f "test/output/test-results.txt" ]; then
  echo "Error: test-results.txt was not created"
  exit 1
fi

# Print the test results
echo "Test results:"
cat "test/output/test-results.txt"

echo "Modular system test passed!"
```

## Next Steps

In the next step, we'll implement output handling and result reporting. This will include:
- Capturing and processing the output of the RooCode workflow
- Generating detailed reports
- Handling errors and edge cases
- Providing clear feedback to the user

We'll build on the modular system integration implemented in this step.